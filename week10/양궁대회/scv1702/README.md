# 문제 풀이

## 문제 해설

백트래킹으로 구현한 조합을 통해 라이언이 이기는 모든 경우의 수를 구했다. 라이언이 이기는 과녁을 선택하고, 해당 과녁에 대해 어피치보다 1발만 더 많이 쏘았다. 이때 쏘는 과정 중 라이언의 화살이 부족하면 해당 경우는 정답이 될 수 없으므로 함수를 조기 반환 시켰다. 

다음 코드가 라이언이 화살을 쏘는 과정이다. `visited[i] == true`인 경우 과녁 `i`는 라이언이 이겨야 하는 과녁이다.

```java
// 라이언이 화살을 쏜다.
// 라이언이 이길 과녁인 경우 어피치보다 한 발만 많이 쏜다.
// 어피치가 이길 과녁인 경우 라이언은 쏘지 않는다.
// 둘 다 아닌 경우 라이언은 쏘지 않는다.
for (int i = 0; i < SIZE; i++) {
    if (visited[i]) { // 라이언이 이길 과녁인 경우
        my += 10 - i;
        if (arrow < apeach[i] + 1) { // 라이언이 쏠 화살이 부족한 경우, 함수 종료
            return ;
        }
        arrow -= apeach[i] + 1;
        rion[i] = apeach[i] + 1;
    } else if (apeach[i] > 0) { // 어피치가 이길 과녁인 경우
        enemy += 10 - i;
    }
}
```

또한 `n`개의 화살을 모두 쏴야하기 때문에, 화살이 남은 경우 0점인 과목에 모두 쏘았다. 왜냐하면, 라이언과 어피치의 점수 차가 같을 때는 가장 낮은 점수를 더 많이 맞힌 경우가 정답이 되기 때문이다. 또한 0점에 모두 쏜다고 해도 승패 변동은 일어나지 않는다.

```java
// 나머지 화살은 0점에 쏜다.
if (arrow > 0) { 
    rion[SIZE - 1] += arrow;
}
```

마지막으로 라이언과 어피치의 점수 차가 이전보다 같거나 큰 경우 라이언의 기록을 갱신했다. 같을 때도 갱신하는 이유는 가장 낮은 점수를 더 많이 맞힌 경우가 정답이기 때문이다. 이는 백트래킹을 이용한 조합의 실행 순서로 인해 자동으로 처리된다.

```java
if (my > enemy && my - enemy >= diff) {
    diff = my - enemy;
    answer = rion;
}
```

## 시간 복잡도

과녁의 최대 점수를 $s$라고 하자. 조합의 경우 한 번 수행하는데 $O(2^s)$가 소요되기 때문에 $O(s \times 2^s)$이다. 