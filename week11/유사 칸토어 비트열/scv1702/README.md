# 문제 풀이

## 문제 해설

유사 칸토어 비트열의 위치 `i`의 값만 알 수 있다면 다음과 같이 정답을 구할 수 있다.

```java
int answer = 0;
for (long i = l - 1; i < r; i++) {
    if (cantor(i) == 1) {
        answer += 1;
    }
}
return answer;
```

`cantor(i)`는 위치 `i`의 비트값을 반환한다. 이제 `cantor(i)`를 구현해보자.

```
n = 0: 1
n = 1: 11011
n = 2: 11011 11011 00000 11011 11011
...
```

위 패턴을 보면, `i % 5 == 2`에 위치하면 비트값은 `0`이다. 왜냐하면 `1`이 `11011`이 되면서 중앙에 `0`을 만들기 때문이다. 그렇다면 연속하는 `0`은 어떻게 처리할까? 이는 위치 `i`의 비트값을 만들게 되는 이전 수열의 비트값을 보면 알 수 있다. 해당 값이 `0`이라면 위치 `i`의 값은 `0`이다. 

그러므로 `cantor(i)`는 다음과 같이 구현할 수 있다.

```java
public int cantor(long i) {
    if (i % 5 == 2) {
        return 0;
    }

    if (i < 5 && i % 5 != 2) {
        return 1;
    }

    return cantor(i / 5);
}
```

## 시간 복잡도

전체 시간 복잡도는 $O((r-l)\times log_5(r))$이다.