# 문제 풀이

## 문제 해설

투포인터 알고리즘을 사용했다. `i`는 시작 진열대 번호, `j`는 끝 진열대 번호를 의미한다. 첫 번째로 모든 종류의 보석을 구매하는 구간을 찾은 뒤, `i`를 점차 증가시키며 최소 길이의 구간을 찾는다. 해당 구간으로 정답을 갱신하고, 다시 `j`를 증가시키며 다음 모든 종류의 보석을 구매하는 구간을 찾는다.

이때 중요한 것은 현재 구간이 모든 종류의 보석을 구매할 수 있는지, 없는지 판단하는 것인데 `HashMap`과 `HashSet`을 적절히 사용하여 구현하였다. `HashMap`은 현재 구매할 수 있는 각 보석의 개수를 저장하고, `HashSet`은 현재 구매할 수 있는 보석의 종류를 저장한다. `HashMap`에서 보석의 개수가 0이될 경우 `HashSet`에서 해당 보석을 삭제시켰다.

## 시간 복잡도

`gems`의 길이를 $n$이라고 할 때 $O(n)$이다.