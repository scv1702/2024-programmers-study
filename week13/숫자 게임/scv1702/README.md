<!-- 다시 풀어볼 것-->

# 문제 풀이

## 문제 해설

A팀의 순서가 고정되어 주어지는데, 그렇다고 해서 `A[]`의 순서를 바꿀 수 없다는 뜻은 아니다. 왜냐하면, `A[]`와 `B[]`를 1:1 대응만 잘 시켜준다면 `A[]`의 순서가 변하더라도 기존의 A팀의 순서를 알고 있기 때문에 기존 순서로 재배열한 뒤 B팀을 해당 순서에 맞춰 출전시키면 되기 때문이다. 사실 이번 문제에서는 B팀이 획득할 수 있는 점수 최대값만 구하면 되기 때문에 굳이 재정렬할 필요는 없다.

B팀의 점수가 최대가 되기 위해, A팀의 숫자가 큰 경우 B팀의 큰 숫자를 출전시키고 A팀의 숫자가 작은 경우 A팀의 작은 숫자를 출전시킨다. 만약 이길 수 없는 경우에는 A팀의 가장 작은 숫자를 차례대로 출전시킨다.

위에서 서술한 대로 `A[]`의 순서를 바꿔도 괜찮기 때문에 `A[]`와 `B[]`를 내림차순으로 정렬한다. 다만, 자바에서 배열을 정렬할 때 `Arrays.sort()`를 사용할 수 있는데 `Comparator`가 제네릭을 사용하기 때문에 참조형 배열일 경우에만 `Arrays.sort()`에 `Comparator`를 넘겨 정렬할 수 있다. 그래서 내림차순이 아닌 오름차순으로 정렬을 한 뒤 배열을 뒤에서부터 접근하는 방식을 사용했다.

```java
Arrays.sort(A);
Arrays.sort(B); 

int j = n - 1;
for (int i = n - 1; i >= 0; i--) {
    if (A[i] < B[j]) {
        answer += 1;
        j -= 1;
    }
}
```

`j`는 `B[]`를 가리킨다. `A[]`와 `B[]`를 비교하면서 `A[i] < B[j]`인 경우, 즉 B팀이 이길 수 있는 경우 `B[j]`를 출전시키고 그렇지 않은 경우 `B[0:j]` 중 어떤 숫자도 `A[i]`를 이길 수 없기 때문에 가장 작은 숫자인 `B[0]`부터 차례대로 출전시킨다. 다만 실제 출전 숫자 순서를 구할 필요는 없기 때문에 `j -= 1`만 수행한다.

## 시간 복잡도

정렬을 수행하기 때문에 $O(n \times \log{n})$이다.