# 문제 풀이

## 문제 해설

작업의 요청부터 종료까지 걸리는 시간은 작업 실행 대기 시간과 작업 소요 시간의 합이다. 작업 소요 시간은 고정된 값이니, 평균을 최소화하기 위해선 작업 실행 대기 시간을 줄여야 한다.

일단 작업 큐가 있고, 작업 요청이 작업 큐에 저장된다고 생각해보자. 작업 큐에서 어떤 정책으로 작업을 꺼내야지 작업 실행 대기 시간의 평균이 최소가 될까? 그리디 적으로 생각했을 때, 작업 큐에 모든 작업을 넣고 작업 소요 시간이 적은 작업부터 꺼내면서 처리하는 것이 좋을 것 같다. 그러나 무작정 작업 소요 시간이 적은 작업을 처리하면 안되는데, 작업의 요청 시점도 고려해야하기 때문이다.

그래서 필자는 작업 큐에 모든 작업을 넣고 시작하는 것이 아닌 그때 그때마다 작업 큐에 작업을 넣는 방식을 사용했다. 먼저 작업 큐의 선언과 작업 요청 배열 `jobs`의 정렬을 다음과 같이 수행한다.

```java
// (작업 소요 시간, 작업 요청 시점)에 대해 정렬
PriorityQueue<int[]> jq = new PriorityQueue<>((j1, j2) -> {
    if (j1[1] == j2[1]) {
        return j1[0] - j2[0];
    }
    return j1[1] - j2[1];
});

// (작업 요청 시점, 작업 소요 시간)에 대해 정렬
Arrays.sort(jobs, (j1, j2) -> { 
    if (j1[0] == j2[0]) {
        return j1[1] - j2[1];
    }
    return j1[0] - j2[0];
});
```

그리고 현재 시간을 나타내는 변수 `t`를 두고, `t = 0`으로 초기화한 뒤 `t`보다 이전에 들어온 요청들을 작업 큐에 넣었다. 그렇게 되면 현재 작업 큐에는 `t` 다음에 들어온 요청이 없기 때문에 일단 실행하는데 문제가 없는 작업들만 존재한다.

```java
int t = 0; // 현재 시간
int i = 0; // 작업 인덱스
int j = 0; // 실행 완료한 작업 수
int answer = 0;

while (j < jobs.length) {
    // 현재 시간 이전인 작업들을 작업 큐에 추가
    for (; i < jobs.length && jobs[i][0] <= t; i++) {
        jq.offer(jobs[i]);
    }
    ...
}
```

이제 작업 큐에서 작업 소요 시간이 가장 적은 작업을 꺼내어 실행하고, `t`를 작업 실행 이후로 갱신한다. 만약 작업 큐에 작업이 없는 경우, 즉 나머지 요청들이 모두  `t` 다음에 들어온 경우 가장 빠르게 들어온 요청 시점으로 `t`를 갱신한다.

```java
while (j < jobs.length) {
    ...
    // 실행할 작업 탐색
    if (!jq.isEmpty()) {
        int[] process = jq.poll();
        answer += (t - process[0]) + process[1];
        t += process[1];
        j += 1;
    } else {
        t = jobs[i][0];
    }
}
```

이를 모든 작업을 처리할 때까지 반복하면 된다.

## 시간 복잡도

작업 개수를 $n$이라고 할 때, 모든 작업이 한 번씩 작업 큐에 들어가고 꺼내지기 때문에  $O(n\log{n})$이다.