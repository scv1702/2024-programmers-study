<!--다시 풀어볼 것-->
# 문제 풀이

## 문제 해설

어떤 풍선 `a[i]`의 오른쪽과 왼쪽 각각에 `a[i]`보다 작은 풍선이 1개 이상 존재한다면, `a[i]`는 항상 터질 수 밖에 없다. 임의의 풍선을 선택하고, 그 풍선의 왼쪽 또는 오른쪽을 터뜨린다고 생각해보면 `a[i]`보다 오른쪽 또는 왼쪽에 항상 `a[i]`보다 큰 풍선만 오거나 최대 한 번 `a[i]`보다 작은 풍선이 온다면 `a[i]`는 터지지 않기 때문이다.

그렇다면, `a[i]`의 오른쪽 또는 왼쪽 한쪽에 `a[i]`보다 작은 값이 몰려있다면 어떨까? 즉, 오름차순 또는 내림차순으로 정렬된 경우를 생각해보자. 그러한 경우 `a[i]`와 `a[i]`의 짝을 제외한 나머지 짝들은 모두 큰 쪽을 터드리고, 마지막에 `a[i]`와 `a[i]`의 짝을 비교해 `a[i]`가 큰 경우 아직 작은 풍선을 터뜨린 적이 없으니 `a[i]`의 짝을, `a[i]`의 짝이 큰 경우 `a[i]`의 짝을 터뜨리면 되기 때문에 `a[i]`는 살아남는다.

즉, 다시 정리하자면 어떤 풍선 항상 터지려면 `a[i]`의 오른쪽과 왼쪽 각각에 `a[i]`보다 작은 풍선이 1개 이상 존재해야 한다.

지금 필요한 것은 `a[i]`의 오른쪽과 왼쪽 각각에 `a[i]`보다 작은 풍선이 최소 1개는 있는지 판단하는 것이다. 이는 `min(a[0:i+1])`의 최소값이 `a[i]`보다 작은지, 그리고 `min(a[i:])`의 최소값이 `a[i]`보다 작은지 판단하면 된다.

이제 어떤 풍선이 터지는지 판단할 수 있으니, 이를 시간 제한 안에 해결할 방법에 대해 생각해봐야한다. 입력값의 크기 $n$의 최대값은 $10^6$으로 상당히 크기 때문에, $O(n^2)$은 불가능하다. 각 `a[i]`마다 `min(a[0:i+1])`와 `min(a[i:])`를 $O(1)$에 판단할 수 있을까? `a`는 고정된 배열이니 미리 선형 탐색으로 계산해놓으면 $O(1)$에 가능하다.

```java
int n = a.length;
int answer = n;
int[] lm = new int[n];
int[] rm = new int[n];
int j = a[0];
for (int i = 0; i < n; i++) {
    lm[i] = j = Math.min(j, a[i]);
}
int k = a[n - 1];
for (int i = n - 1; i >= 0; i--) {
    rm[i] = k = Math.min(k, a[i]);
}
for (int i = 0; i < n; i++) {
    if (lm[i] < a[i] && rm[i] < a[i]) {
        answer -= 1;
    }
}
```

## 시간 복잡도

전체 시간 복잡도는 $O(n)$이다.