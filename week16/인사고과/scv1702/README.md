<!--다시 풀어볼 것-->
# 문제 풀이

## 문제 해설

문제에서 조심해야할 점은, 어떤 사원이 다른 임의의 사원보다 두 점수가 모두 낮은 경우가 **한 번이라도** 존재하는 경우 인센티브를 받을 수 없다는 것이다. 인센티브를 받을 수 없는 사원을 구하기 위해 한 점수를 기준으로 내림차순 정렬을 한다. 필자는 근무 태도 점수를 기준으로 하겠다.

근무 태도 점수를 기준으로 내림차순 정렬을 하면, `scores[i]`는 `scores[0:i]`보다 근무 태도 점수가 같거나 낮다. 일단 `scores[i]`가 `scores[0:i]`보다 근무 태도 점수가 낮다고 하자. `scores[i]`가 인센티브를 받으려면 `scores[i]`의 동료 평가 점수가 `scores[0:i]`의 동료 평가 점수 최대값보다 높거나 같아야 한다. 그렇지 않으면, `scores[i]`보다 두 점수가 모두 큰 사원이 존재하기 때문이다.

그렇다면, `scores[i]`가 `scores[0:i]`와 근무 태도 점수가 같은 경우는 어떨까? 근무 태도 점수가 같기 때문에 동료 평가 점수와 상관 없이 인센티브를 받을 수 있다.

두 가지 경우를 한 번의 `for` 문으로 처리할 수 있도록 두 번째 정렬 기준으로 동료 평가 점수를 오름차순으로 설정하자. 이를 통해 `scores[i]`가 `scores[0:i]`와 근무 태도 점수가 같다면 항상 동료 평가 점수가 더 높기 때문에, `scores[i]`의 동료 평가 점수가 최대값보다 낮은지만 판단하면 된다.

```java
// 근무 태도 desc, 동료 평가 asc
Arrays.sort(scores, (s1, s2) -> {
    if (s2[0] == s1[0]) {
        return s1[1] - s2[1];
    }
    return s2[0] - s1[0];
});

int max_b = scores[0][1]; // 동료 평가 최대값

for (int i = 0; i < n; i++) {
    if (scores[i][1] < max_b) {
        if (scores[i] == me) return -1;
        scores[i] = null;
    } else {
        max_b = Math.max(max_b, scores[i][1]);
    }
}
```

## 시간 복잡도

전체 시간 복잡도는 $O(n\log{n})$이다. 