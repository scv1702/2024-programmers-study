<!--다시 풀어볼 것-->
# 문제 풀이

## 문제 해설

단순히 `board` 배열에 매번 `skill`을 적용하면 시간 초과가 발생하기 때문에, 이를 최적화 해줘야할 필요가 있다.

1차원 배열 `arr`이 있을 때, `arr[0:i+1]`에 숫자 `x`을 더하고 싶으면 `arr[0] = x`, `arr[i+1] = -x`를 하고 `arr[0:i+1]`의 누적합을 구하면 된다. 예시를 들어, `arr[0:6]`에 5를 더해보자.

1. `arr[0] = 5`, `arr[6] = -5`를 수행한다.

```
[5, 0, 0, 0, 0, 0, -5]
```

2. `arr[0:6]`의 누적합을 구한다.

```
[5, 5, 5, 5, 5, 5, 0]
```

위 방법의 장점은 `arr`의 매번 특정 구간마다 같은 값을 더해줘야할 경우 시작점과 끝점만 값을 채워주면 마지막 한 번의 누적합으로 계산을 끝낼 수 있다는 장점이 있다.

이제 이를 2차원 배열에 대해 확장을 해보면, `arr[r1][c1]`에서 `arr[r2][c2]`까지 숫자 `x`를 더하고 싶다고 하자. 2차원 배열의 경우 1차원 배열에서 수행한 것을 행과 열에 대해 각각 한 번씩 수행하면 된다. 예시를 들어, `arr[0][0]`에서 `arr[5][5]`에 5를 더해보자.

1. `arr[0][0] = 5`, `arr[0][6] = -5`, `arr[6][0] = -5`, `arr[6][6] = 5`를 수행한다.

```
[ 5,  0,  0,  0,  0,  0, -5]
[ 0,  0,  0,  0,  0,  0,  0]
[ 0,  0,  0,  0,  0,  0,  0]
[ 0,  0,  0,  0,  0,  0,  0]
[ 0,  0,  0,  0,  0,  0,  0]
[ 0,  0,  0,  0,  0,  0,  0]
[-5,  0,  0,  0,  0,  0,  5]
```

2. 행 방향의 누적합을 구한다.

```
[ 5,  5,  5,  5,  5,  5, 0]
[ 0,  0,  0,  0,  0,  0, 0]
[ 0,  0,  0,  0,  0,  0, 0]
[ 0,  0,  0,  0,  0,  0, 0]
[ 0,  0,  0,  0,  0,  0, 0]
[ 0,  0,  0,  0,  0,  0, 0]
[-5, -5, -5, -5, -5, -5, 0]
```

3. 열 방향의 누적합을 구한다.

```
[5, 5, 5, 5, 5, 5, 0]
[5, 5, 5, 5, 5, 5, 0]
[5, 5, 5, 5, 5, 5, 0]
[5, 5, 5, 5, 5, 5, 0]
[5, 5, 5, 5, 5, 5, 0]
[5, 5, 5, 5, 5, 5, 0]
[0, 0, 0, 0, 0, 0, 0]
```

## 시간 복잡도

`skills`의 길이를 $s$라고 할 때 전체 시간 복잡도는 $O(s + n \times m)$