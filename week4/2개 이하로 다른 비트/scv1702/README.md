# 문제 풀이

## 문제 해설

본 문제는 비트 조작 문제다. 양의 정수 $x$에 대해 $x$보다 크고 $x$와 비트가 1 ~ 2개 다른 수들 중에서 제일 작은 수를 찾아야 한다. 이는 $x$가 짝수일 때와 홀수일 때로 나뉜다.

### 1. $x$가 짝수인 경우

$x$가 짝수인 경우, $x$의 LSB는 0이다. 이때 $x+1$은 $x$와 다른 비트는 모두 동일하고, LSB만 1로 다른 수이다. 그러므로 $f(x)=x+1$이다.

### 2. $x$가 홀수인 경우

$x$가 홀수인 경우는 살짝 복잡하다. $x$가 홀수인 경우 LSB가 1이기 때문에 1을 더할 경우 어떤 위치의 비트가 바뀔지 $x$의 값에 따라 달라지기 때문이다. 그렇다고 $x$에서 1씩 계속 더해보면서 찾는 방법은 시간이 오래 걸린다.

비트 연산을 통해 $f(x)$를 찾을 수 없을까? 문제의 조건을 생각해보면, $f(x)$의 후보는 한정적이다. $x$와 비트가 2개만 다른 수들은 $x$에서 값이 서로 다른 두 비트가 서로 바뀌는 경우 밖에 될 수 없다. 이와 동시에 $x$보다 크면서 제일 작아야 한다. 이는 $x$의 Trailing zero의 위치를 $i$라고 할 때 $x_i$와 $x_{i-1}$를 서로 바꾸면 된다.

그렇다면 $x$가 홀수 일 때 비트가 1개만 다른 $f(x)$는 존재할 수 없을까? 예시를 들어 생각해보면 알겠지만, 그런 경우는 모두 $x$보다 크면서 비트가 1 ~ 2개 다른 수들 중 제일 작은 경우가 아니기 때문에 존재할 수 없다.

## 시간 복잡도

`numbers`의 길이를 $n$이라고 하자. $x$의 최대 크기는 $10^{15}$이므로 Trailing zero를 찾는 연산은 $O(15)$이다. 그러므로 전체 시간 복잡도는 $O(15n)=O(n)$이다.