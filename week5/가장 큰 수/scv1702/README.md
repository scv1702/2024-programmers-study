# 문제 풀이

## 문제 해설

본 문제는 숫자 목록 `numbers`가 주어졌을 때, 이어 붙여서 만들 수 있는 가장 큰 수를 구해야 한다. 이때 `numbers[i]`를 뒤집거나 쪼갤 순 없다. 완전 탐색을 생각해보면 `numbers`의 모든 순열을 구한 뒤 이어 붙여서 가장 큰 수가 되는 순열을 구할 수 있을 것 같다. 그러나 `numbers`의 길이가 길기 때문에 완전 탐색은 할 수 없다.

이어 붙였을 때 가장 큰 수가 되려면 어떻게 해야 할까? 단순하게 생각해보면 `numbers[i]`를 내림차순으로 정렬하면, 이어 붙었을 때 가장 큰 수가 될 수 있을 것 같다. 이는 `numbers[i]`가 9 이하였다면 가능하겠지만 10 이상도 올 수 있기 때문에 불가능하다. 왜냐하면, `[10, 9]`의 경우 910이 정답이지만 109가 되버리기 때문이다.

그렇다면 단순 크기 순으로 정렬하는게 아닌 이어 붙였을 때 크기를 비교하면 어떨까? `[10, 9]`의 경우 10과 9를 비교해 정렬하는게 아니라, 109와 910을 비교하는 것이다. 이어 붙였을 때 크기 순으로 정렬을 하게 되면, 이를 모두 연결한 수가 가장 큰 수가 되는 것은 자명하다.

단, 이때 `numbers[i]`가 모두 0인 경우를 대비해 정답으로 구한 수의 마지막 자리가 0인 경우 0을 반환하도록 처리해야 한다.

## 시간 복잡도

먼저 이어 붙이는 과정을 쉽게 하기 위해 `numbers` 배열을 `String[]`으로 변환하고($O(n)$), `Arrays.sort()`를 수행($O(n\log(n))$)했다. 그러므로 전체 시간 복잡도는 $O(n\log(n))$이다. `Arrays.sort()`의 각 원소 비교 시 `Integer.toString()`을 수행하나 `numbers[i]`의 최대값이 $10^3$이기 때문에 상수 시간이 걸린다.