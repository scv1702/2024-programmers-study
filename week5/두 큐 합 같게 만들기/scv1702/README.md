# 문제 풀이

## 문제 해설

혼자서 최대한 풀어보려고 했으나.. 하루 종일 고민해봐도 풀이법이 떠오르지 않아 답안지를 참고했다. 내가 찾은 풀이법은 총 2가지가 있었는데, 투 포인터를 이용한 것과 그리디를 이용한 풀이다. 본 문제는 레벨 2문제기 때문에 투 포인터를 이용한 풀이는 적절하지 않다고 생각해 그리디 풀이에 집중해서 해설해보겠다.

일단, 문제를 읽어보면 **길이가 같은** 두 큐가 주어지고, `pop`과 `insert` 연산을 통해 두 큐의 합을 동일하게 만들어야 한다고 한다. 이때 `pop`과 `insert`는 한 번에 이루어진다고 하고, 두 큐의 합을 동일하게 만들 때 필요한 최소의 연산 수를 구해야 한다. 가장 먼저 해야할 것은 일단 주어진 배열 `queue1`과 `queue2`를 통해 실제 큐인 `q1`가 `q2`를 만드는 것이다.

```java
Deque<Integer> q1 = new ArrayDeque<>();
Deque<Integer> q2 = new ArrayDeque<>();

for (int i = 0; i < n; i++) {
    q1.add(queue1[i]);
    s1 += queue1[i];
    target += queue1[i];
}

for (int i = 0; i < n; i++) {
    q2.add(queue2[i]);
    target += queue2[i];
}
```

이때 `s1`은 현재 `q1`에 있는 원소들의 합, `target`은 `q1`과 `q2`의 전체 합이다. 두 큐 합이 같으려면 `target`이 2의 배수이어야 하기 때문에 만약 2의 배수가 아니라면 바로 -1을 반환한다.

```java
if (target % 2 != 0) {
    return -1;
}

target /= 2;
```

그리고 `target`을 반으로 나누어 `s1`이 목표로 해야 하는 값으로 만든다. 

이제 어떻게 하면 `q1`과 `q2`의 합을 동일하게 만드는 최소 연산 수를 찾을 수 있을까? 일단 `queue1`과 `queue2`의 길이가 최대 $3\times 10^5$이기 때문에 완전 탐색의 꿈은 물 건너간 것을 알 수 있다. 동적 계획법 또한 지금 상황에서는 겹치는 구조가 보이지 않기 때문에 사용할 수 없을 것 같다. 이럴 때는 그리디를 사용할 수 없을까 생각해보자.

그리디 적으로 생각 해본다면, 연산을 최소로 하기 위해선 합이 큰 쪽에서 작은 쪽으로 원소를 보내야 한다. 만약, 작은 쪽에서 큰 쪽으로 보내게 된다면 언젠가는 다시 큰 쪽에서 값을 받아야지 `target`이 되기 때문이다. 만약 작은 쪽에서 큰 쪽으로 보내기만 한다면 해당 큐의 합은 0이 될 것이다.

또한 큐는 `pop`을 할 때 먼저 들어온 원소 순으로 나가기 때문에, 각 큐에 적용될 `pop` 횟수가 정해진다면 어떤 순서로 `pop`을 하던 간에 마지막의 결과는 같다. 예를 들어 `q1 = [3, 2, 7, 2]`, `q2 = [4, 6, 5, 1]`라고 하자. 그리고 `q1`에 `pop`을 3번하고 `q2`에 `pop`을 2번 한다고 가정하면,

```java
q2.offer(q1.poll()); q2.offer(q1.poll()); q2.offer(q1.poll());
q1.offer(q2.poll()); q1.offer(q2.poll());
```

을 하는 것과

```java
q1.offer(q2.poll()); q1.offer(q2.poll());
q2.offer(q1.poll()); q2.offer(q1.poll()); q2.offer(q1.poll());
```

을 하는 것,

```java
q1.offer(q2.poll());
q2.offer(q1.poll()); 
q1.offer(q2.poll());
q2.offer(q1.poll()); 
q2.offer(q1.poll());
```

을 하는 것 등은 모두 `q1 = [2, 4, 6]`, `q2 = [5, 1, 3, 2, 7]`로 동일하다. 그러므로 어떤 큐의 합이 더 클 경우 바로 `pop`을 하면 된다. 이를 반복하다가 `s1 == target`이 되는 지점의 연산 횟수가 바로 답이 된다.

근데, 이를 반복하면 항상 `s1 == target`이 되는 경우가 존재할까? `queue1`와 `queue2`의 길이를 `n`이라고 할 때, 해가 존재하지 않는 경우를 대비해 연산을 `4*n`  번 하고도 답을 찾지 못했다면 -1을 반환하도록 하자. 연산을 `4*n`번 했다면 어느 한 큐에서는 `pop`이 `2*n` 번 발생 하면서 초기 상태로 돌아오기 때문에, 그 동안 `s1 == target`이 되지 않았다면 답이 존재하지 않는 경우다.

```java
for (int i = 0; i < 4 * n; i++) {
    if (s1 > target) {
        int temp = q1.poll();
        s1 -= temp;
        q2.offer(temp);
    } else if (s1 == target) {
        return i;
    } else if (s1 < target) {
        int temp = q2.poll();
        s1 += temp;
        q1.offer(temp);
    }
}
```

## 시간 복잡도

전체 시간 복잡도는 $O(4n)$이다.